/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 * OpenAPI spec version: 1.0.7
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query';

import type { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';
import axios from 'axios';

import type {
  ApiResponse,
  FindPetsByStatusParams,
  FindPetsByTagsParams,
  Pet,
  PetBody,
  UpdatePetWithFormBody,
  UploadFileBody,
} from '../../models';

/**
 * @summary uploads an image
 */
export const uploadFile = (
  petId: number,
  uploadFileBody: UploadFileBody,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<ApiResponse>> => {
  const formData = new FormData();
  if (uploadFileBody.additionalMetadata !== undefined) {
    formData.append(`additionalMetadata`, uploadFileBody.additionalMetadata);
  }
  if (uploadFileBody.file !== undefined) {
    formData.append(`file`, uploadFileBody.file);
  }

  return axios.post(`https://petstore.swagger.io/v2/pet/${petId}/uploadImage`, formData, options);
};

export const getUploadFileMutationOptions = <
  TError = AxiosError<unknown>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof uploadFile>>,
    TError,
    { petId: number; data: UploadFileBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof uploadFile>>,
  TError,
  { petId: number; data: UploadFileBody },
  TContext
> => {
  const mutationKey = ['uploadFile'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof uploadFile>>,
    { petId: number; data: UploadFileBody }
  > = (props) => {
    const { petId, data } = props ?? {};

    return uploadFile(petId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UploadFileMutationResult = NonNullable<Awaited<ReturnType<typeof uploadFile>>>;
export type UploadFileMutationBody = UploadFileBody;
export type UploadFileMutationError = AxiosError<unknown>;

/**
 * @summary uploads an image
 */
export const useUploadFile = <TError = AxiosError<unknown>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof uploadFile>>,
      TError,
      { petId: number; data: UploadFileBody },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof uploadFile>>,
  TError,
  { petId: number; data: UploadFileBody },
  TContext
> => {
  const mutationOptions = getUploadFileMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Add a new pet to the store
 */
export const addPet = (
  petBody: PetBody,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.post(`https://petstore.swagger.io/v2/pet`, petBody, options);
};

export const getAddPetMutationOptions = <TError = AxiosError<void>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof addPet>>,
    TError,
    { data: PetBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<Awaited<ReturnType<typeof addPet>>, TError, { data: PetBody }, TContext> => {
  const mutationKey = ['addPet'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof addPet>>, { data: PetBody }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return addPet(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AddPetMutationResult = NonNullable<Awaited<ReturnType<typeof addPet>>>;
export type AddPetMutationBody = PetBody;
export type AddPetMutationError = AxiosError<void>;

/**
 * @summary Add a new pet to the store
 */
export const useAddPet = <TError = AxiosError<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof addPet>>,
      TError,
      { data: PetBody },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof addPet>>, TError, { data: PetBody }, TContext> => {
  const mutationOptions = getAddPetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Update an existing pet
 */
export const updatePet = (
  petBody: PetBody,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.put(`https://petstore.swagger.io/v2/pet`, petBody, options);
};

export const getUpdatePetMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePet>>,
    TError,
    { data: PetBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePet>>,
  TError,
  { data: PetBody },
  TContext
> => {
  const mutationKey = ['updatePet'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof updatePet>>, { data: PetBody }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return updatePet(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdatePetMutationResult = NonNullable<Awaited<ReturnType<typeof updatePet>>>;
export type UpdatePetMutationBody = PetBody;
export type UpdatePetMutationError = AxiosError<void>;

/**
 * @summary Update an existing pet
 */
export const useUpdatePet = <TError = AxiosError<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updatePet>>,
      TError,
      { data: PetBody },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updatePet>>,
  TError,
  { data: PetBody },
  TContext
> => {
  const mutationOptions = getUpdatePetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * Multiple status values can be provided with comma separated strings
 * @summary Finds Pets by status
 */
export const findPetsByStatus = (
  params: FindPetsByStatusParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Pet[]>> => {
  return axios.get(`https://petstore.swagger.io/v2/pet/findByStatus`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getFindPetsByStatusQueryKey = (params: FindPetsByStatusParams) => {
  return [`https://petstore.swagger.io/v2/pet/findByStatus`, ...(params ? [params] : [])] as const;
};

export const getFindPetsByStatusInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof findPetsByStatus>>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByStatusParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof findPetsByStatus>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindPetsByStatusQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findPetsByStatus>>> = ({ signal }) =>
    findPetsByStatus(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof findPetsByStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindPetsByStatusInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof findPetsByStatus>>
>;
export type FindPetsByStatusInfiniteQueryError = AxiosError<void>;

export function useFindPetsByStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findPetsByStatus>>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByStatusParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof findPetsByStatus>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPetsByStatus>>,
          TError,
          Awaited<ReturnType<typeof findPetsByStatus>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindPetsByStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findPetsByStatus>>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByStatusParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof findPetsByStatus>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPetsByStatus>>,
          TError,
          Awaited<ReturnType<typeof findPetsByStatus>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindPetsByStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findPetsByStatus>>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByStatusParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof findPetsByStatus>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Finds Pets by status
 */

export function useFindPetsByStatusInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findPetsByStatus>>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByStatusParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof findPetsByStatus>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindPetsByStatusInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getFindPetsByStatusQueryOptions = <
  TData = Awaited<ReturnType<typeof findPetsByStatus>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByStatusParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findPetsByStatus>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindPetsByStatusQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findPetsByStatus>>> = ({ signal }) =>
    findPetsByStatus(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findPetsByStatus>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindPetsByStatusQueryResult = NonNullable<Awaited<ReturnType<typeof findPetsByStatus>>>;
export type FindPetsByStatusQueryError = AxiosError<void>;

export function useFindPetsByStatus<
  TData = Awaited<ReturnType<typeof findPetsByStatus>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByStatusParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof findPetsByStatus>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPetsByStatus>>,
          TError,
          Awaited<ReturnType<typeof findPetsByStatus>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindPetsByStatus<
  TData = Awaited<ReturnType<typeof findPetsByStatus>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByStatusParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findPetsByStatus>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPetsByStatus>>,
          TError,
          Awaited<ReturnType<typeof findPetsByStatus>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindPetsByStatus<
  TData = Awaited<ReturnType<typeof findPetsByStatus>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByStatusParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findPetsByStatus>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Finds Pets by status
 */

export function useFindPetsByStatus<
  TData = Awaited<ReturnType<typeof findPetsByStatus>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByStatusParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findPetsByStatus>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindPetsByStatusQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
 * @deprecated
 * @summary Finds Pets by tags
 */
export const findPetsByTags = (
  params: FindPetsByTagsParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Pet[]>> => {
  return axios.get(`https://petstore.swagger.io/v2/pet/findByTags`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getFindPetsByTagsQueryKey = (params: FindPetsByTagsParams) => {
  return [`https://petstore.swagger.io/v2/pet/findByTags`, ...(params ? [params] : [])] as const;
};

export const getFindPetsByTagsInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof findPetsByTags>>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByTagsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindPetsByTagsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findPetsByTags>>> = ({ signal }) =>
    findPetsByTags(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof findPetsByTags>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindPetsByTagsInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof findPetsByTags>>
>;
export type FindPetsByTagsInfiniteQueryError = AxiosError<void>;

export function useFindPetsByTagsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findPetsByTags>>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByTagsParams,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPetsByTags>>,
          TError,
          Awaited<ReturnType<typeof findPetsByTags>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindPetsByTagsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findPetsByTags>>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByTagsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPetsByTags>>,
          TError,
          Awaited<ReturnType<typeof findPetsByTags>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindPetsByTagsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findPetsByTags>>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByTagsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @deprecated
 * @summary Finds Pets by tags
 */

export function useFindPetsByTagsInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof findPetsByTags>>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByTagsParams,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindPetsByTagsInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getFindPetsByTagsQueryOptions = <
  TData = Awaited<ReturnType<typeof findPetsByTags>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByTagsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getFindPetsByTagsQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof findPetsByTags>>> = ({ signal }) =>
    findPetsByTags(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof findPetsByTags>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type FindPetsByTagsQueryResult = NonNullable<Awaited<ReturnType<typeof findPetsByTags>>>;
export type FindPetsByTagsQueryError = AxiosError<void>;

export function useFindPetsByTags<
  TData = Awaited<ReturnType<typeof findPetsByTags>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByTagsParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPetsByTags>>,
          TError,
          Awaited<ReturnType<typeof findPetsByTags>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindPetsByTags<
  TData = Awaited<ReturnType<typeof findPetsByTags>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByTagsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof findPetsByTags>>,
          TError,
          Awaited<ReturnType<typeof findPetsByTags>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useFindPetsByTags<
  TData = Awaited<ReturnType<typeof findPetsByTags>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByTagsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @deprecated
 * @summary Finds Pets by tags
 */

export function useFindPetsByTags<
  TData = Awaited<ReturnType<typeof findPetsByTags>>,
  TError = AxiosError<void>,
>(
  params: FindPetsByTagsParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof findPetsByTags>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getFindPetsByTagsQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns a single pet
 * @summary Find pet by ID
 */
export const getPetById = (
  petId: number,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<Pet>> => {
  return axios.get(`https://petstore.swagger.io/v2/pet/${petId}`, options);
};

export const getGetPetByIdQueryKey = (petId: number) => {
  return [`https://petstore.swagger.io/v2/pet/${petId}`] as const;
};

export const getGetPetByIdInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getPetById>>>,
  TError = AxiosError<void>,
>(
  petId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPetByIdQueryKey(petId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPetById>>> = ({ signal }) =>
    getPetById(petId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!petId,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetPetByIdInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof getPetById>>>;
export type GetPetByIdInfiniteQueryError = AxiosError<void>;

export function useGetPetByIdInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPetById>>>,
  TError = AxiosError<void>,
>(
  petId: number,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPetById>>,
          TError,
          Awaited<ReturnType<typeof getPetById>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPetByIdInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPetById>>>,
  TError = AxiosError<void>,
>(
  petId: number,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPetById>>,
          TError,
          Awaited<ReturnType<typeof getPetById>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPetByIdInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPetById>>>,
  TError = AxiosError<void>,
>(
  petId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Find pet by ID
 */

export function useGetPetByIdInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getPetById>>>,
  TError = AxiosError<void>,
>(
  petId: number,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPetByIdInfiniteQueryOptions(petId, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetPetByIdQueryOptions = <
  TData = Awaited<ReturnType<typeof getPetById>>,
  TError = AxiosError<void>,
>(
  petId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetPetByIdQueryKey(petId);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getPetById>>> = ({ signal }) =>
    getPetById(petId, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!petId,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetPetByIdQueryResult = NonNullable<Awaited<ReturnType<typeof getPetById>>>;
export type GetPetByIdQueryError = AxiosError<void>;

export function useGetPetById<
  TData = Awaited<ReturnType<typeof getPetById>>,
  TError = AxiosError<void>,
>(
  petId: number,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPetById>>,
          TError,
          Awaited<ReturnType<typeof getPetById>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPetById<
  TData = Awaited<ReturnType<typeof getPetById>>,
  TError = AxiosError<void>,
>(
  petId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getPetById>>,
          TError,
          Awaited<ReturnType<typeof getPetById>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetPetById<
  TData = Awaited<ReturnType<typeof getPetById>>,
  TError = AxiosError<void>,
>(
  petId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Find pet by ID
 */

export function useGetPetById<
  TData = Awaited<ReturnType<typeof getPetById>>,
  TError = AxiosError<void>,
>(
  petId: number,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getPetById>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetPetByIdQueryOptions(petId, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Updates a pet in the store with form data
 */
export const updatePetWithForm = (
  petId: number,
  updatePetWithFormBody: UpdatePetWithFormBody,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  const formUrlEncoded = new URLSearchParams();
  if (updatePetWithFormBody.name !== undefined) {
    formUrlEncoded.append(`name`, updatePetWithFormBody.name);
  }
  if (updatePetWithFormBody.status !== undefined) {
    formUrlEncoded.append(`status`, updatePetWithFormBody.status);
  }

  return axios.post(`https://petstore.swagger.io/v2/pet/${petId}`, formUrlEncoded, options);
};

export const getUpdatePetWithFormMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updatePetWithForm>>,
    TError,
    { petId: number; data: UpdatePetWithFormBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updatePetWithForm>>,
  TError,
  { petId: number; data: UpdatePetWithFormBody },
  TContext
> => {
  const mutationKey = ['updatePetWithForm'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updatePetWithForm>>,
    { petId: number; data: UpdatePetWithFormBody }
  > = (props) => {
    const { petId, data } = props ?? {};

    return updatePetWithForm(petId, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdatePetWithFormMutationResult = NonNullable<
  Awaited<ReturnType<typeof updatePetWithForm>>
>;
export type UpdatePetWithFormMutationBody = UpdatePetWithFormBody;
export type UpdatePetWithFormMutationError = AxiosError<void>;

/**
 * @summary Updates a pet in the store with form data
 */
export const useUpdatePetWithForm = <TError = AxiosError<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updatePetWithForm>>,
      TError,
      { petId: number; data: UpdatePetWithFormBody },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updatePetWithForm>>,
  TError,
  { petId: number; data: UpdatePetWithFormBody },
  TContext
> => {
  const mutationOptions = getUpdatePetWithFormMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Deletes a pet
 */
export const deletePet = (
  petId: number,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.delete(`https://petstore.swagger.io/v2/pet/${petId}`, options);
};

export const getDeletePetMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deletePet>>,
    TError,
    { petId: number },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deletePet>>,
  TError,
  { petId: number },
  TContext
> => {
  const mutationKey = ['deletePet'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePet>>, { petId: number }> = (
    props,
  ) => {
    const { petId } = props ?? {};

    return deletePet(petId, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeletePetMutationResult = NonNullable<Awaited<ReturnType<typeof deletePet>>>;

export type DeletePetMutationError = AxiosError<void>;

/**
 * @summary Deletes a pet
 */
export const useDeletePet = <TError = AxiosError<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deletePet>>,
      TError,
      { petId: number },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deletePet>>,
  TError,
  { petId: number },
  TContext
> => {
  const mutationOptions = getDeletePetMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
