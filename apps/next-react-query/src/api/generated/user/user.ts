/**
 * Generated by orval v7.10.0 üç∫
 * Do not edit manually.
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 * OpenAPI spec version: 1.0.7
 */
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseInfiniteQueryResult,
  DefinedUseQueryResult,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseInfiniteQueryOptions,
  UseInfiniteQueryResult,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';
import { useInfiniteQuery, useMutation, useQuery } from '@tanstack/react-query';

import type { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';
import axios from 'axios';

import type { LoginUserParams, User, UserArrayBody } from '../../models';

/**
 * @summary Creates list of users with given input array
 */
export const createUsersWithListInput = (
  userArrayBody: UserArrayBody,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.post(`https://petstore.swagger.io/v2/user/createWithList`, userArrayBody, options);
};

export const getCreateUsersWithListInputMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUsersWithListInput>>,
    TError,
    { data: UserArrayBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUsersWithListInput>>,
  TError,
  { data: UserArrayBody },
  TContext
> => {
  const mutationKey = ['createUsersWithListInput'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUsersWithListInput>>,
    { data: UserArrayBody }
  > = (props) => {
    const { data } = props ?? {};

    return createUsersWithListInput(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateUsersWithListInputMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUsersWithListInput>>
>;
export type CreateUsersWithListInputMutationBody = UserArrayBody;
export type CreateUsersWithListInputMutationError = AxiosError<void>;

/**
 * @summary Creates list of users with given input array
 */
export const useCreateUsersWithListInput = <TError = AxiosError<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUsersWithListInput>>,
      TError,
      { data: UserArrayBody },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createUsersWithListInput>>,
  TError,
  { data: UserArrayBody },
  TContext
> => {
  const mutationOptions = getCreateUsersWithListInputMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get user by user name
 */
export const getUserByName = (
  username: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<User>> => {
  return axios.get(`https://petstore.swagger.io/v2/user/${username}`, options);
};

export const getGetUserByNameQueryKey = (username: string) => {
  return [`https://petstore.swagger.io/v2/user/${username}`] as const;
};

export const getGetUserByNameInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getUserByName>>>,
  TError = AxiosError<void>,
>(
  username: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserByNameQueryKey(username);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserByName>>> = ({ signal }) =>
    getUserByName(username, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!username,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetUserByNameInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserByName>>
>;
export type GetUserByNameInfiniteQueryError = AxiosError<void>;

export function useGetUserByNameInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserByName>>>,
  TError = AxiosError<void>,
>(
  username: string,
  options: {
    query: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserByName>>,
          TError,
          Awaited<ReturnType<typeof getUserByName>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUserByNameInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserByName>>>,
  TError = AxiosError<void>,
>(
  username: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserByName>>,
          TError,
          Awaited<ReturnType<typeof getUserByName>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUserByNameInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserByName>>>,
  TError = AxiosError<void>,
>(
  username: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get user by user name
 */

export function useGetUserByNameInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getUserByName>>>,
  TError = AxiosError<void>,
>(
  username: string,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData>
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUserByNameInfiniteQueryOptions(username, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getGetUserByNameQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserByName>>,
  TError = AxiosError<void>,
>(
  username: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserByNameQueryKey(username);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserByName>>> = ({ signal }) =>
    getUserByName(username, { signal, ...axiosOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!username,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };
};

export type GetUserByNameQueryResult = NonNullable<Awaited<ReturnType<typeof getUserByName>>>;
export type GetUserByNameQueryError = AxiosError<void>;

export function useGetUserByName<
  TData = Awaited<ReturnType<typeof getUserByName>>,
  TError = AxiosError<void>,
>(
  username: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserByName>>,
          TError,
          Awaited<ReturnType<typeof getUserByName>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUserByName<
  TData = Awaited<ReturnType<typeof getUserByName>>,
  TError = AxiosError<void>,
>(
  username: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof getUserByName>>,
          TError,
          Awaited<ReturnType<typeof getUserByName>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetUserByName<
  TData = Awaited<ReturnType<typeof getUserByName>>,
  TError = AxiosError<void>,
>(
  username: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get user by user name
 */

export function useGetUserByName<
  TData = Awaited<ReturnType<typeof getUserByName>>,
  TError = AxiosError<void>,
>(
  username: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof getUserByName>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getGetUserByNameQueryOptions(username, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * This can only be done by the logged in user.
 * @summary Updated user
 */
export const updateUser = (
  username: string,
  user: User,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.put(`https://petstore.swagger.io/v2/user/${username}`, user, options);
};

export const getUpdateUserMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof updateUser>>,
    TError,
    { username: string; data: User },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { username: string; data: User },
  TContext
> => {
  const mutationKey = ['updateUser'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof updateUser>>,
    { username: string; data: User }
  > = (props) => {
    const { username, data } = props ?? {};

    return updateUser(username, data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>;
export type UpdateUserMutationBody = User;
export type UpdateUserMutationError = AxiosError<void>;

/**
 * @summary Updated user
 */
export const useUpdateUser = <TError = AxiosError<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof updateUser>>,
      TError,
      { username: string; data: User },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof updateUser>>,
  TError,
  { username: string; data: User },
  TContext
> => {
  const mutationOptions = getUpdateUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * This can only be done by the logged in user.
 * @summary Delete user
 */
export const deleteUser = (
  username: string,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<unknown>> => {
  return axios.delete(`https://petstore.swagger.io/v2/user/${username}`, options);
};

export const getDeleteUserMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteUser>>,
    TError,
    { username: string },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { username: string },
  TContext
> => {
  const mutationKey = ['deleteUser'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteUser>>,
    { username: string }
  > = (props) => {
    const { username } = props ?? {};

    return deleteUser(username, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>;

export type DeleteUserMutationError = AxiosError<void>;

/**
 * @summary Delete user
 */
export const useDeleteUser = <TError = AxiosError<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof deleteUser>>,
      TError,
      { username: string },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof deleteUser>>,
  TError,
  { username: string },
  TContext
> => {
  const mutationOptions = getDeleteUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Logs user into the system
 */
export const loginUser = (
  params: LoginUserParams,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<string>> => {
  return axios.get(`https://petstore.swagger.io/v2/user/login`, {
    ...options,
    params: { ...params, ...options?.params },
  });
};

export const getLoginUserQueryKey = (params: LoginUserParams) => {
  return [`https://petstore.swagger.io/v2/user/login`, ...(params ? [params] : [])] as const;
};

export const getLoginUserInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof loginUser>>>,
  TError = AxiosError<void>,
>(
  params: LoginUserParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof loginUser>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLoginUserQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof loginUser>>> = ({ signal }) =>
    loginUser(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof loginUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LoginUserInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof loginUser>>>;
export type LoginUserInfiniteQueryError = AxiosError<void>;

export function useLoginUserInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof loginUser>>>,
  TError = AxiosError<void>,
>(
  params: LoginUserParams,
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof loginUser>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof loginUser>>,
          TError,
          Awaited<ReturnType<typeof loginUser>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useLoginUserInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof loginUser>>>,
  TError = AxiosError<void>,
>(
  params: LoginUserParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof loginUser>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof loginUser>>,
          TError,
          Awaited<ReturnType<typeof loginUser>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useLoginUserInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof loginUser>>>,
  TError = AxiosError<void>,
>(
  params: LoginUserParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof loginUser>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Logs user into the system
 */

export function useLoginUserInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof loginUser>>>,
  TError = AxiosError<void>,
>(
  params: LoginUserParams,
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof loginUser>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getLoginUserInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLoginUserQueryOptions = <
  TData = Awaited<ReturnType<typeof loginUser>>,
  TError = AxiosError<void>,
>(
  params: LoginUserParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof loginUser>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLoginUserQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof loginUser>>> = ({ signal }) =>
    loginUser(params, { signal, ...axiosOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof loginUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LoginUserQueryResult = NonNullable<Awaited<ReturnType<typeof loginUser>>>;
export type LoginUserQueryError = AxiosError<void>;

export function useLoginUser<
  TData = Awaited<ReturnType<typeof loginUser>>,
  TError = AxiosError<void>,
>(
  params: LoginUserParams,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof loginUser>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof loginUser>>,
          TError,
          Awaited<ReturnType<typeof loginUser>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useLoginUser<
  TData = Awaited<ReturnType<typeof loginUser>>,
  TError = AxiosError<void>,
>(
  params: LoginUserParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof loginUser>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof loginUser>>,
          TError,
          Awaited<ReturnType<typeof loginUser>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useLoginUser<
  TData = Awaited<ReturnType<typeof loginUser>>,
  TError = AxiosError<void>,
>(
  params: LoginUserParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof loginUser>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Logs user into the system
 */

export function useLoginUser<
  TData = Awaited<ReturnType<typeof loginUser>>,
  TError = AxiosError<void>,
>(
  params: LoginUserParams,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof loginUser>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getLoginUserQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Logs out current logged in user session
 */
export const logoutUser = (options?: AxiosRequestConfig): Promise<AxiosResponse<void>> => {
  return axios.get(`https://petstore.swagger.io/v2/user/logout`, options);
};

export const getLogoutUserQueryKey = () => {
  return [`https://petstore.swagger.io/v2/user/logout`] as const;
};

export const getLogoutUserInfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof logoutUser>>>,
  TError = AxiosError<void>,
>(options?: {
  query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof logoutUser>>, TError, TData>>;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogoutUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logoutUser>>> = ({ signal }) =>
    logoutUser({ signal, ...axiosOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof logoutUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogoutUserInfiniteQueryResult = NonNullable<Awaited<ReturnType<typeof logoutUser>>>;
export type LogoutUserInfiniteQueryError = AxiosError<void>;

export function useLogoutUserInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logoutUser>>>,
  TError = AxiosError<void>,
>(
  options: {
    query: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof logoutUser>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logoutUser>>,
          TError,
          Awaited<ReturnType<typeof logoutUser>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useLogoutUserInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logoutUser>>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<Awaited<ReturnType<typeof logoutUser>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logoutUser>>,
          TError,
          Awaited<ReturnType<typeof logoutUser>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useLogoutUserInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logoutUser>>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof logoutUser>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Logs out current logged in user session
 */

export function useLogoutUserInfinite<
  TData = InfiniteData<Awaited<ReturnType<typeof logoutUser>>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<UseInfiniteQueryOptions<Awaited<ReturnType<typeof logoutUser>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getLogoutUserInfiniteQueryOptions(options);

  const query = useInfiniteQuery(queryOptions, queryClient) as UseInfiniteQueryResult<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey;

  return query;
}

export const getLogoutUserQueryOptions = <
  TData = Awaited<ReturnType<typeof logoutUser>>,
  TError = AxiosError<void>,
>(options?: {
  query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof logoutUser>>, TError, TData>>;
  axios?: AxiosRequestConfig;
}) => {
  const { query: queryOptions, axios: axiosOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getLogoutUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof logoutUser>>> = ({ signal }) =>
    logoutUser({ signal, ...axiosOptions });

  return { queryKey, queryFn, staleTime: 10000, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof logoutUser>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LogoutUserQueryResult = NonNullable<Awaited<ReturnType<typeof logoutUser>>>;
export type LogoutUserQueryError = AxiosError<void>;

export function useLogoutUser<
  TData = Awaited<ReturnType<typeof logoutUser>>,
  TError = AxiosError<void>,
>(
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof logoutUser>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof logoutUser>>,
          TError,
          Awaited<ReturnType<typeof logoutUser>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useLogoutUser<
  TData = Awaited<ReturnType<typeof logoutUser>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof logoutUser>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof logoutUser>>,
          TError,
          Awaited<ReturnType<typeof logoutUser>>
        >,
        'initialData'
      >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useLogoutUser<
  TData = Awaited<ReturnType<typeof logoutUser>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof logoutUser>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Logs out current logged in user session
 */

export function useLogoutUser<
  TData = Awaited<ReturnType<typeof logoutUser>>,
  TError = AxiosError<void>,
>(
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof logoutUser>>, TError, TData>>;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getLogoutUserQueryOptions(options);

  const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * @summary Creates list of users with given input array
 */
export const createUsersWithArrayInput = (
  userArrayBody: UserArrayBody,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.post(`https://petstore.swagger.io/v2/user/createWithArray`, userArrayBody, options);
};

export const getCreateUsersWithArrayInputMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUsersWithArrayInput>>,
    TError,
    { data: UserArrayBody },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUsersWithArrayInput>>,
  TError,
  { data: UserArrayBody },
  TContext
> => {
  const mutationKey = ['createUsersWithArrayInput'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof createUsersWithArrayInput>>,
    { data: UserArrayBody }
  > = (props) => {
    const { data } = props ?? {};

    return createUsersWithArrayInput(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateUsersWithArrayInputMutationResult = NonNullable<
  Awaited<ReturnType<typeof createUsersWithArrayInput>>
>;
export type CreateUsersWithArrayInputMutationBody = UserArrayBody;
export type CreateUsersWithArrayInputMutationError = AxiosError<void>;

/**
 * @summary Creates list of users with given input array
 */
export const useCreateUsersWithArrayInput = <TError = AxiosError<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUsersWithArrayInput>>,
      TError,
      { data: UserArrayBody },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<
  Awaited<ReturnType<typeof createUsersWithArrayInput>>,
  TError,
  { data: UserArrayBody },
  TContext
> => {
  const mutationOptions = getCreateUsersWithArrayInputMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * This can only be done by the logged in user.
 * @summary Create user
 */
export const createUser = (
  user: User,
  options?: AxiosRequestConfig,
): Promise<AxiosResponse<void>> => {
  return axios.post(`https://petstore.swagger.io/v2/user`, user, options);
};

export const getCreateUserMutationOptions = <
  TError = AxiosError<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof createUser>>,
    TError,
    { data: User },
    TContext
  >;
  axios?: AxiosRequestConfig;
}): UseMutationOptions<
  Awaited<ReturnType<typeof createUser>>,
  TError,
  { data: User },
  TContext
> => {
  const mutationKey = ['createUser'];
  const { mutation: mutationOptions, axios: axiosOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, axios: undefined };

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, { data: User }> = (
    props,
  ) => {
    const { data } = props ?? {};

    return createUser(data, axiosOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>;
export type CreateUserMutationBody = User;
export type CreateUserMutationError = AxiosError<void>;

/**
 * @summary Create user
 */
export const useCreateUser = <TError = AxiosError<void>, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof createUser>>,
      TError,
      { data: User },
      TContext
    >;
    axios?: AxiosRequestConfig;
  },
  queryClient?: QueryClient,
): UseMutationResult<Awaited<ReturnType<typeof createUser>>, TError, { data: User }, TContext> => {
  const mutationOptions = getCreateUserMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
